<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// === Game Parameters ===
const int WIDTH = 16;
const int HEIGHT = 8;
const int MAP_SIZE = WIDTH * HEIGHT;
const int LONGEST_PATH = 26;



// === Game variables ===
int enemy_cont = 0;

// === CHANNELS ===
broadcast chan movement;
broadcast chan turret_notify;
broadcast chan enemy_leave;
broadcast chan end_all;


// === Turrets Parameters ===

//Turrets

//Turrets Damage
const int SNIPER_ATK = 8;
const int CANNON_ATK = 5;
const int BASIC_ATK = 2;

//Turrets Range
const int SNIPER_RANGE = 4;
const int CANNON_RANGE = 1;
const int BASIC_RANGE = 2;

//Turrets Rate of Fire
const int SNIPER_ROF = 20;
const int CANNON_ROF = 7;
const int BASIC_ROF = 2;

//struct position
typedef struct {
    int x;
    int y;
} Position;

//Turrets state arrays;


// === Configuration I ===
/*
const int NUM_TURRETS = 7;
typedef int[0, NUM_TURRETS-1] id_t;
broadcast chan shoot[id_t];
int ranges[id_t] = {SNIPER_RANGE, BASIC_RANGE, CANNON_RANGE, CANNON_RANGE, SNIPER_RANGE, CANNON_RANGE, CANNON_RANGE};
int rofs[id_t] = {SNIPER_ROF, BASIC_ROF, CANNON_ROF, CANNON_ROF, SNIPER_ROF, CANNON_ROF, CANNON_ROF};
int atks[id_t] = {SNIPER_ATK, BASIC_ATK, CANNON_ATK, CANNON_ATK, SNIPER_ATK, CANNON_ATK, CANNON_ATK};
const Position locations[id_t] = {{2,3}, {5,5}, {8,2}, {8,6}, {11,5}, {14,2}, {14,6}};
*/
/*
// === Configuration II ===
const int NUM_TURRETS = 6;
typedef int[0, NUM_TURRETS-1] id_t;
broadcast chan shoot[id_t];
int ranges[id_t] = {SNIPER_RANGE, SNIPER_RANGE, SNIPER_RANGE, SNIPER_RANGE, SNIPER_RANGE, SNIPER_RANGE};
int rofs[id_t] = {SNIPER_ROF, SNIPER_ROF, SNIPER_ROF, SNIPER_ROF, SNIPER_ROF, SNIPER_ROF};
int atks[id_t] = {SNIPER_ATK, SNIPER_ATK, SNIPER_ATK, SNIPER_ATK, SNIPER_ATK, SNIPER_ATK};
const Position locations[id_t] = {{2,3}, {5,5}, {8,2}, {8,6}, {11,5}, {14,2}};
*/


// === Configuration III ===
const int NUM_TURRETS = 7;
typedef int[0, NUM_TURRETS-1] id_t;
broadcast chan shoot[id_t];
int ranges[id_t] = {BASIC_RANGE, CANNON_RANGE, CANNON_RANGE, CANNON_RANGE, CANNON_RANGE, CANNON_RANGE, SNIPER_RANGE};
int rofs[id_t] = {BASIC_ROF, CANNON_ROF, CANNON_ROF, CANNON_ROF, CANNON_ROF, CANNON_ROF, SNIPER_ROF};
int atks[id_t] = {BASIC_ATK, CANNON_ATK, CANNON_ATK, CANNON_ATK, CANNON_ATK, CANNON_ATK, SNIPER_ATK};
const Position locations[id_t] = {{2,3}, {5,5}, {8,2}, {8,6}, {11,5}, {14,2}, {14,6}};




// === Enemies Parameters ===

// Enemies
const int NUM_CIRCLES = 400;
const int NUM_SQUARES = 300;
typedef int[0, NUM_CIRCLES-1] id_c;
typedef int[0, NUM_SQUARES-1] id_s;
const int num_enemy = NUM_CIRCLES + NUM_SQUARES;

//Enemies Speeds
const int CIRCLE_SPEED = 1;
const int SQUARE_SPEED = 3;

//Enemies Health
const int CIRCLE_HEALTH = 10;
const int SQUARE_HEALTH = 20;

//Enenmies Damage
const int CIRCLE_DAMAGE = 2;
const int SQUARE_DAMAGE = 4;

//Enenmies Spawning
const int CIRCLE_SPAWN_INTERVAL = 2;
const int SQUARE_SPAWN_INTERVAL = 3;

// Enemy position variables
int START_X = 0;
int START_Y = 0;

int sqrs_pos[NUM_SQUARES][2];
int circles_pos[NUM_CIRCLES][2];

// Main Tower
int mainTowerHP = 100;

// Enemy state arrays
int circle_health[NUM_CIRCLES];
bool circle_alive[NUM_CIRCLES];

int square_health[NUM_SQUARES];
bool square_alive[NUM_SQUARES];

//to save when the enemy instance has started
int activation_order[NUM_SQUARES+NUM_CIRCLES];
int activation_counter = 0;
// Clock for simulation
clock globalClock;



// Cell types
const int WALL = 0;
const int PATH = 1;
const int TURRET = 2;
const int ENTRY = 3;
const int MAIN = 4;
const int SQUARE = 5;
const int CIRCLE = 6;

// Main Tower position
const int MAIN_X = 15;
const int MAIN_Y = 4;

// Bifurcation points
const int BIFURCATION1_X = 7;
const int BIFURCATION1_Y = 4;
const int BIFURCATION2_X = 10;
const int BIFURCATION2_Y = 7;

int map[HEIGHT][WIDTH] = {
//x= 0     1     2       3     4     5       6     7       8       9     10    11      12    13    14      15
    {PATH, 0,    0,      0,    0,    0,      0,    0,      0,      0,    0,    0,      0,    0,    0,      0},    // y = 0
    {PATH, 0,    0,      0,    0,    0,      0,    PATH,   PATH,   PATH, PATH, PATH,   PATH, PATH, PATH,   PATH}, // y = 1
    {PATH, 0,    0,      0,    0,    0,      0,    PATH,   TURRET, 0,    0,    0,      0,    0,    TURRET, PATH}, // y = 2
    {PATH, 0,    TURRET, 0,    0,    0,      0,    PATH,   0,      0,    0,    0,      0,    0,    0,      PATH}, // y = 3
    {PATH, PATH, PATH,   PATH, PATH, PATH,   PATH, PATH,   0,      0,    PATH, PATH,   PATH, PATH, PATH,   PATH}, // y = 4
    {0,    0,    0,      0,    0,    TURRET, 0,    PATH,   0,      0,    PATH, TURRET, 0,    0,    0,      PATH}, // y = 5
    {0,    0,    0,      0,    0,    0,      0,    PATH,   TURRET, 0,    PATH, 0,      0,    0,    TURRET, PATH}, // y = 6
    {0,    0,    0,      0,    0,    0,      0,    PATH,   PATH,   PATH, PATH, PATH,   PATH, PATH, PATH,   PATH}  // y = 7
};

/*int id_inMap[HEIGHT][WIDTH] = {
//x= 0     1     2       3     4     5       6     7       8       9     10    11      12    13    14      15
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 0
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 1
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 2
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 3
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 4
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 5
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 6
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}  // y = 7
};*/


/**
* applies damage to the enemy target, function used by turrets
* @param target_id    The id number of the target
* @param dmg          Turret damage that will be applied
*/
void apply_damage(int target_id, int dmg) {
    if (target_id &lt; NUM_SQUARES)
        square_health[target_id] -= dmg;
    else
        circle_health[target_id - NUM_SQUARES] -= dmg;
}



</declaration>
	<template>
		<name>Map</name>
		<declaration>bool end; //guard condition, if true the game must be ended, otherwise the game must continue

/**
* Evaluates conditions to end the game, either all enemies were killed/left the map
* or the main tower was destroyed
* @return condition evaluation
*/
bool check_end() {
    return (enemy_cont == num_enemy || mainTowerHP == 0);
}
</declaration>
		<location id="id0" x="-646" y="-187">
			<name x="-656" y="-221">Idle</name>
		</location>
		<location id="id1" x="-289" y="-187">
			<name x="-299" y="-221">GameOver</name>
		</location>
		<location id="id2" x="-799" y="-187">
			<committed/>
		</location>
		<location id="id3" x="-425" y="-187">
			<committed/>
		</location>
		<init ref="id0"/>
		<transition id="id4">
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="guard" x="-373" y="-230">end</label>
			<label kind="synchronisation" x="-391" y="-212">end_all!</label>
			<nail x="-348" y="-187"/>
		</transition>
		<transition id="id5">
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="guard" x="-561" y="-127">!end</label>
			<nail x="-544" y="-136"/>
		</transition>
		<transition id="id6">
			<source ref="id0"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-595" y="-229">enemy_leave?</label>
			<label kind="assignment" x="-612" y="-212">end := check_end()</label>
		</transition>
		<transition id="id7">
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-824" y="-127">turret_notify!</label>
			<nail x="-731" y="-127"/>
		</transition>
		<transition id="id8">
			<source ref="id0"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-765" y="-204">movement?</label>
		</transition>
	</template>
	<template>
		<name>EnemySquare</name>
		<parameter>int id</parameter>
		<declaration>clock t; //local clock
int x = 0;  //enemy local x coordinate variable used to pass values
int y = 0;  //enemy local y coordinate variable used to pass values
int health; //local health variable used to pass values
int prev_x = -1; //saves the previous x coordinate before moving
int prev_y = -1; //saves the previous y coordinate before moving
bool bifurcation; //indicates whether or not we reached a bifurcation
bool ReachMainTower = false; //indicates whether or not the main tower has been reached

int next[2][2] = {
    {-1, -1},
    {-1, -1}
}; // Array of possible next [x,y] positions

/**
* Updates the enemy position in the global state array
*/
void updatePositions(){
    sqrs_pos[id][0] = x;
    sqrs_pos[id][1] = y;
}

/**
* Initializes the enemy position in the global state array
*/
void initializePositions(){
    sqrs_pos[id][0] = 0;
    sqrs_pos[id][1] = 0;
}



/**
* Returns possible next positions from (x,y)
* @param x         Current x-coordinate
* @param y         Current y-coordinate
* @param prev_x    Previous x-coordinate
* @param prev_y    Previous y-coordinate
*/
void getNextPositions(int x, int y, int prev_x, int prev_y) {
    
    next[0][0] = -1;
    next[0][1] = -1;
    next[1][0] = -1;
    next[1][1] = -1;
    bifurcation = false;
     
    // Main Tower reached - no further movement
    if(x == MAIN_X &amp;&amp; y == MAIN_Y) {
        return;
    }
    
    // Bifurcation point 1
    if(x == BIFURCATION1_X &amp;&amp; y == BIFURCATION1_Y) {
        // Move up
        next[0][0] = x;
        next[0][1] = y+1;
         // Move down
        next[1][0] = x;
        next[1][1] = y-1;
        bifurcation = true;
        return;
    }
    
    // Bifurcation point 2
    if(x == BIFURCATION2_X &amp;&amp; y == BIFURCATION2_Y) {
        // Move down
        next[0][0] = x;
        next[0][1] = y-1;
        // Move right
        next[1][0] = x+1;
        next[1][1] = y;
        bifurcation = true;
        return;
    }
    
    // Horizontal movement
    if (x+1 != prev_x || y != prev_y){
        if (x &lt; WIDTH - 1 &amp;&amp; map[y][x + 1] == PATH) {
            next[0][0] = x + 1;
            next[0][1] = y;
            return;
        }
    }
    // Vertical movement
    if (y &lt; HEIGHT - 1 &amp;&amp; map[y + 1][x] == PATH &amp;&amp; !(x == prev_x &amp;&amp; y+1 == prev_y)) {
        next[0][0] = x;
        next[0][1] = y + 1;
        return;
    }
    if (y &gt; 0 &amp;&amp; map[y - 1][x] == PATH &amp;&amp; !(x == prev_x &amp;&amp; y-1 == prev_y)) {
        next[0][0] = x;
        next[0][1] = y - 1;
        return;
    }
    // Edge case handling
    return ;
}</declaration>
		<location id="id9" x="-2031" y="-1181">
			<name x="-2048" y="-1215">Spawn</name>
			<label kind="invariant" x="-2091" y="-1164">t&lt;=SQUARE_SPAWN_INTERVAL*(id+1)</label>
		</location>
		<location id="id10" x="-884" y="-739">
			<name x="-894" y="-773">Decide</name>
			<urgent/>
		</location>
		<location id="id11" x="-212" y="-739">
			<name x="-195" y="-773">Attack</name>
			<label kind="exponentialrate" x="-195" y="-748">SQUARE_SPEED : 10</label>
		</location>
		<location id="id12" x="-552" y="-739">
			<name x="-562" y="-773">Leave</name>
		</location>
		<location id="id13" x="-1487" y="-739">
			<name x="-1649" y="-756">Move_bifurcation</name>
			<label kind="exponentialrate" x="-1649" y="-731">SQUARE_SPEED : 10</label>
			<label kind="testcodeEnter">getNextPositions(x, y);</label>
		</location>
		<location id="id14" x="-1487" y="-1181">
			<name x="-1623" y="-1215">prepare_to_move</name>
			<urgent/>
		</location>
		<location id="id15" x="-884" y="-1181">
			<name x="-894" y="-1215">Move</name>
			<label kind="exponentialrate" x="-935" y="-1164">SQUARE_SPEED : 10</label>
		</location>
		<location id="id16" x="-221" y="-1436">
			<name x="-231" y="-1470">prepare_to_attack</name>
			<label kind="exponentialrate" x="-204" y="-1445">SQUARE_SPEED : 10</label>
		</location>
		<init ref="id9"/>
		<transition id="id17">
			<source ref="id16"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-323" y="-1079">end_all?</label>
			<nail x="-340" y="-824"/>
		</transition>
		<transition id="id18">
			<source ref="id15"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-714" y="-1164">end_all?</label>
			<nail x="-629" y="-1130"/>
		</transition>
		<transition id="id19">
			<source ref="id13"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-1428" y="-629">end_all?</label>
			<nail x="-1292" y="-459"/>
			<nail x="-612" y="-459"/>
		</transition>
		<transition id="id20">
			<source ref="id14"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-1207" y="-1122">end_all?</label>
			<nail x="-977" y="-1062"/>
		</transition>
		<transition id="id21">
			<source ref="id10"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-866" y="-565">end_all?</label>
			<nail x="-884" y="-544"/>
			<nail x="-629" y="-552"/>
		</transition>
		<transition id="id22">
			<source ref="id16"/>
			<target ref="id12"/>
			<label kind="guard" x="-544" y="-1326">square_health[id] &lt;= 0</label>
			<label kind="synchronisation" x="-544" y="-1215">enemy_leave!</label>
			<label kind="assignment" x="-544" y="-1292">square_alive[id] := false,
health := square_health[id],
enemy_cont++,
t := 0</label>
			<nail x="-374" y="-1326"/>
			<nail x="-374" y="-918"/>
		</transition>
		<transition id="id23">
			<source ref="id13"/>
			<target ref="id12"/>
			<label kind="guard" x="-1469" y="-450">square_health[id] &lt;= 0</label>
			<label kind="synchronisation" x="-1470" y="-467">enemy_leave!</label>
			<label kind="assignment" x="-1470" y="-416">square_alive[id] := false,
health := square_health[id],
enemy_cont++,
t := 0</label>
			<nail x="-1487" y="-416"/>
			<nail x="-552" y="-416"/>
		</transition>
		<transition id="id24">
			<source ref="id15"/>
			<target ref="id12"/>
			<label kind="guard" x="-595" y="-1096">square_health[id] &lt;= 0</label>
			<label kind="synchronisation" x="-595" y="-986">enemy_leave!</label>
			<label kind="assignment" x="-595" y="-1071">square_alive[id] := false,
health := square_health[id],
enemy_cont++,
t := 0</label>
			<nail x="-552" y="-1181"/>
		</transition>
		<transition id="id25">
			<source ref="id14"/>
			<target ref="id16"/>
			<label kind="guard" x="-1615" y="-1351">next[0][0] == MAIN_X &amp;&amp; next[0][1] == MAIN_Y</label>
			<nail x="-1487" y="-1436"/>
		</transition>
		<transition id="id26">
			<source ref="id15"/>
			<target ref="id10"/>
			<label kind="guard" x="-875" y="-1130">t &gt;= SQUARE_SPEED &amp;&amp;
next[0][0] != -1 &amp;&amp; 
next[0][1] != -1 &amp;&amp;
square_health[id] &gt; 0</label>
			<label kind="synchronisation" x="-875" y="-884">movement!</label>
			<label kind="assignment" x="-875" y="-1045">prev_x = x, 
prev_y = y,
x = next[0][0], 
y = next[0][1],
updatePositions(),
health := square_health[id],
t := 0</label>
		</transition>
		<transition id="id27">
			<source ref="id14"/>
			<target ref="id13"/>
			<label kind="guard" x="-1530" y="-969">bifurcation</label>
			<label kind="assignment" x="-1530" y="-952">health := square_health[id]</label>
		</transition>
		<transition id="id28">
			<source ref="id14"/>
			<target ref="id15"/>
			<label kind="guard" x="-1428" y="-1207">!bifurcation &amp;&amp; (next[0][0] != MAIN_X || next[0][1] != MAIN_Y)</label>
			<label kind="assignment" x="-1419" y="-1181">health := square_health[id]</label>
		</transition>
		<transition id="id29">
			<source ref="id10"/>
			<target ref="id12"/>
			<label kind="guard" x="-850" y="-739">square_health[id] &lt;= 0</label>
			<label kind="synchronisation" x="-858" y="-629">enemy_leave!</label>
			<label kind="assignment" x="-858" y="-714">square_alive[id] := false,
health := square_health[id],
enemy_cont++,
t := 0</label>
		</transition>
		<transition id="id30">
			<source ref="id10"/>
			<target ref="id14"/>
			<label kind="guard" x="-1275" y="-1037">square_health[id] &gt; 0</label>
			<label kind="assignment" x="-1266" y="-1020">getNextPositions(x, y, prev_x, prev_y),
health := square_health[id],
t:=0</label>
		</transition>
		<transition id="id31">
			<source ref="id13"/>
			<target ref="id10"/>
			<label kind="select" x="-1275" y="-731">i : int[0,1]</label>
			<label kind="guard" x="-1275" y="-714">t &gt;= SQUARE_SPEED &amp;&amp;
next[i][0] != -1 &amp;&amp; 
next[i][1] != -1 &amp;&amp; square_health[id] &gt; 0</label>
			<label kind="synchronisation" x="-1275" y="-493">movement!</label>
			<label kind="assignment" x="-1275" y="-654">prev_x = x, 
prev_y = y,
x = next[i][0], 
y = next[i][1],
updatePositions(),
health := square_health[id],
t := 0</label>
		</transition>
		<transition id="id32">
			<source ref="id9"/>
			<target ref="id14"/>
			<label kind="guard" x="-1810" y="-1164">t &gt;= SQUARE_SPAWN_INTERVAL * (id+1)</label>
			<label kind="synchronisation" x="-1844" y="-977">movement!</label>
			<label kind="assignment" x="-1844" y="-1139">t := 0, 
initializePositions(),
activation_order[id] := activation_counter,
activation_counter++,
square_alive[id] := true, 
square_health[id] := SQUARE_HEALTH,
health := square_health[id],
getNextPositions(x, y, prev_x, prev_y)</label>
		</transition>
		<transition id="id33">
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="guard" x="-527" y="-731">t &gt;= SQUARE_SPEED</label>
			<label kind="synchronisation" x="-527" y="-629">enemy_leave!</label>
			<label kind="assignment" x="-527" y="-705">square_alive[id] := false,
health := 0,
enemy_cont++,
t := 0</label>
		</transition>
		<transition id="id34">
			<source ref="id16"/>
			<target ref="id11"/>
			<label kind="guard" x="-204" y="-1343">t &gt;= SQUARE_SPEED &amp;&amp; square_health[id] &gt; 0</label>
			<label kind="assignment" x="-204" y="-1317">prev_x = x,
prev_y = y,
x = next[0][0],
y = next[0][1],
updatePositions(),
mainTowerHP = mainTowerHP-SQUARE_DAMAGE,
ReachMainTower = true,
t := 0</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">EnemyCircle</name>
		<parameter>int id</parameter>
		<declaration>clock t;  //local clock
int x = 0;  //enemy local x coordinate variable used to pass values
int y = 0;  //enemy local y coordinate variable used to pass values
int health; //local health variable used to pass values
int prev_x = -1;  //saves the previous x coordinate before moving
int prev_y = -1;  //saves the previous y coordinate before moving
bool bifurcation; //indicates whether or not we reached a bifurcation
bool ReachMainTower = false;  //indicates whether or not the main tower has been reached

int next[2][2] = {
    {-1, -1},
    {-1, -1}
}; // Array of possible next [x,y] positions

/**
* Updates the enemy position in the global state array
*/
void updatePositions(){
    circles_pos[id][0] = x;
    circles_pos[id][1] = y;
}

/**
* Initializes the enemy position in the global state array
*/
void initializePositions(){
    circles_pos[id][0] = 0;
    circles_pos[id][1] = 0;
}


/**
* Returns possible next positions from (x,y)
* @param x         Current x-coordinate
* @param y         Current y-coordinate
* @param prev_x    Previous x-coordinate
* @param prev_y    Previous y-coordinate
*/
void getNextPositions(int x, int y, int prev_x, int prev_y) {
    
    next[0][0] = -1;
    next[0][1] = -1;
    next[1][0] = -1;
    next[1][1] = -1;
    bifurcation = false;
     
    // Main Tower reached - no further movement
    if(x == MAIN_X &amp;&amp; y == MAIN_Y) {
        return;
    }
    
    // Bifurcation point 1
    if(x == BIFURCATION1_X &amp;&amp; y == BIFURCATION1_Y) {
        // Move up
        next[0][0] = x;
        next[0][1] = y+1;
         // Move down
        next[1][0] = x;
        next[1][1] = y-1;
        bifurcation = true;
        return;
    }
    
    // Bifurcation point 2
    if(x == BIFURCATION2_X &amp;&amp; y == BIFURCATION2_Y) {
        // Move down
        next[0][0] = x;
        next[0][1] = y-1;
        // Move right
        next[1][0] = x+1;
        next[1][1] = y;
        bifurcation = true;
        return;
    }
    
    // Default forward movement
    if (x+1 != prev_x || y != prev_y){
        if (x &lt; WIDTH - 1 &amp;&amp; map[y][x + 1] == PATH) {
            next[0][0] = x + 1;
            next[0][1] = y;
            return;
        }
    }
    // Vertical movement
    if (y &lt; HEIGHT - 1 &amp;&amp; map[y + 1][x] == PATH &amp;&amp; !(x == prev_x &amp;&amp; y+1 == prev_y)) {
        next[0][0] = x;
        next[0][1] = y + 1;
        return;
    }
    if (y &gt; 0 &amp;&amp; map[y - 1][x] == PATH &amp;&amp; !(x == prev_x &amp;&amp; y-1 == prev_y)) {
        next[0][0] = x;
        next[0][1] = y - 1;
        return;
    }
    // Edge case handling
    return ;
}</declaration>
		<location id="id35" x="-1351" y="-323">
			<name x="-1361" y="-357">Spawn</name>
			<label kind="invariant" x="-1445" y="-306">t&lt;=CIRCLE_SPAWN_INTERVAL*(id+1)</label>
		</location>
		<location id="id36" x="8" y="194">
			<name x="-2" y="160">decide</name>
			<urgent/>
		</location>
		<location id="id37" x="739" y="195">
			<name x="729" y="161">Attack</name>
			<label kind="exponentialrate" x="729" y="229">CIRCLE_SPEED : 10</label>
		</location>
		<location id="id38" x="348" y="195">
			<name x="338" y="161">Leave</name>
		</location>
		<location id="id39" x="-790" y="194">
			<name x="-935" y="161">Move_bifurcation</name>
			<label kind="exponentialrate" x="-800" y="228">CIRCLE_SPEED : 10</label>
		</location>
		<location id="id40" x="-790" y="-323">
			<name x="-850" y="-365">prepare_to_move</name>
			<urgent/>
		</location>
		<location id="id41" x="8" y="-323">
			<name x="-2" y="-357">Move</name>
			<label kind="exponentialrate" x="0" y="-306">CIRCLE_SPEED : 10</label>
		</location>
		<location id="id42" x="731" y="-578">
			<name x="721" y="-612">prepare_to_attack</name>
			<label kind="exponentialrate" x="748" y="-595">CIRCLE_SPEED : 10</label>
		</location>
		<init ref="id35"/>
		<transition id="id43">
			<source ref="id40"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="-612" y="-297">end_all?</label>
			<nail x="-51" y="-187"/>
			<nail x="-8" y="93"/>
		</transition>
		<transition id="id44">
			<source ref="id39"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="-680" y="280">end_all?</label>
			<nail x="-467" y="442"/>
			<nail x="314" y="433"/>
		</transition>
		<transition id="id45">
			<source ref="id36"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="26" y="331">end_all?</label>
			<nail x="8" y="348"/>
			<nail x="289" y="348"/>
		</transition>
		<transition id="id46">
			<source ref="id41"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="195" y="-255">end_all?</label>
			<nail x="246" y="-212"/>
		</transition>
		<transition id="id47">
			<source ref="id42"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="544" y="68">end_all?</label>
			<nail x="603" y="59"/>
		</transition>
		<transition id="id48">
			<source ref="id42"/>
			<target ref="id38"/>
			<label kind="guard" x="408" y="-229">circle_health[id] &lt;= 0</label>
			<label kind="synchronisation" x="408" y="-127">enemy_leave!</label>
			<label kind="assignment" x="408" y="-204">circle_alive[id] := false,
health := circle_health[id],
enemy_cont++,
t := 0</label>
		</transition>
		<transition id="id49">
			<source ref="id41"/>
			<target ref="id38"/>
			<label kind="guard" x="323" y="-68">circle_health[id] &lt;= 0</label>
			<label kind="synchronisation" x="323" y="42">enemy_leave!</label>
			<label kind="assignment" x="323" y="-42">circle_alive[id] := false,
health := circle_health[id],
enemy_cont++,
t := 0</label>
			<nail x="348" y="-323"/>
		</transition>
		<transition id="id50">
			<source ref="id39"/>
			<target ref="id38"/>
			<label kind="guard" x="-772" y="425">circle_health[id] &lt;= 0</label>
			<label kind="synchronisation" x="-773" y="408">enemy_leave!</label>
			<label kind="assignment" x="-772" y="459">circle_alive[id] := false,
health := circle_health[id],
enemy_cont++,
t := 0</label>
			<nail x="-790" y="459"/>
			<nail x="348" y="459"/>
		</transition>
		<transition id="id51">
			<source ref="id40"/>
			<target ref="id42"/>
			<label kind="guard" x="-772" y="-612">next[0][0] == MAIN_X &amp;&amp; next[0][1] == MAIN_Y</label>
			<nail x="-790" y="-578"/>
		</transition>
		<transition id="id52">
			<source ref="id41"/>
			<target ref="id36"/>
			<label kind="guard" x="17" y="-221">t &gt;= CIRCLE_SPEED &amp;&amp;
next[0][0] != -1 &amp;&amp; 
next[0][1] != -1 &amp;&amp; 
circle_health[id] &gt; 0</label>
			<label kind="synchronisation" x="17" y="25">movement!</label>
			<label kind="assignment" x="17" y="-119">prev_x = x, 
prev_y = y,
x = next[0][0], 
y = next[0][1],
updatePositions(),
health := circle_health[id],
t := 0</label>
		</transition>
		<transition id="id53">
			<source ref="id40"/>
			<target ref="id41"/>
			<label kind="guard" x="-731" y="-340">!bifurcation &amp;&amp; (next[0][0] != MAIN_X || next[0][1] != MAIN_Y)</label>
			<label kind="assignment" x="-731" y="-323">health := circle_health[id]</label>
		</transition>
		<transition id="id54">
			<source ref="id40"/>
			<target ref="id39"/>
			<label kind="guard" x="-790" y="-93">bifurcation</label>
			<label kind="assignment" x="-790" y="-64">health := circle_health[id]</label>
		</transition>
		<transition id="id55">
			<source ref="id36"/>
			<target ref="id38"/>
			<label kind="guard" x="59" y="204">circle_health[id] &lt;= 0</label>
			<label kind="synchronisation" x="59" y="306">enemy_leave!</label>
			<label kind="assignment" x="59" y="221">circle_alive[id] := false,
health := circle_health[id],
enemy_cont++,
t := 0</label>
		</transition>
		<transition id="id56">
			<source ref="id36"/>
			<target ref="id40"/>
			<label kind="guard" x="-399" y="-187">circle_health[id] &gt; 0</label>
			<label kind="assignment" x="-408" y="-161">getNextPositions(x, y, prev_x, prev_y),
health := circle_health[id],
t:=0</label>
		</transition>
		<transition id="id57">
			<source ref="id39"/>
			<target ref="id36"/>
			<label kind="select" x="-459" y="195">i : int[0,1]</label>
			<label kind="guard" x="-459" y="220">t &gt;= CIRCLE_SPEED &amp;&amp;
next[i][0] != -1 &amp;&amp; 
next[i][1] != -1 &amp;&amp; circle_health[id] &gt; 0</label>
			<label kind="synchronisation" x="-459" y="170">movement!</label>
			<label kind="assignment" x="-459" y="280">prev_x = x, 
prev_y = y,
x = next[i][0], 
y = next[i][1],
updatePositions(),
health := circle_health[id],
t := 0</label>
		</transition>
		<transition id="id58">
			<source ref="id35"/>
			<target ref="id40"/>
			<label kind="guard" x="-1190" y="-324">t &gt;= CIRCLE_SPAWN_INTERVAL * (id+1)</label>
			<label kind="synchronisation" x="-1190" y="-136">movement!</label>
			<label kind="assignment" x="-1190" y="-297">t := 0, 
initializePositions(),
activation_order[id + NUM_SQUARES] := activation_counter,
activation_counter++,
circle_alive[id] := true, 
circle_health[id] := CIRCLE_HEALTH,
health := circle_health[id],
getNextPositions(x, y, prev_x, prev_y)</label>
		</transition>
		<transition id="id59">
			<source ref="id37"/>
			<target ref="id38"/>
			<label kind="guard" x="459" y="204">t &gt;= CIRCLE_SPEED</label>
			<label kind="synchronisation" x="459" y="306">enemy_leave!</label>
			<label kind="assignment" x="459" y="229">circle_alive[id] := false,
health := 0,
enemy_cont++,
t := 0</label>
		</transition>
		<transition id="id60">
			<source ref="id42"/>
			<target ref="id37"/>
			<label kind="guard" x="748" y="-374">t &gt;= CIRCLE_SPEED &amp;&amp; circle_health[id] &gt; 0</label>
			<label kind="assignment" x="748" y="-348">prev_x = x,
prev_y = y,
x = next[0][0],
y = next[0][1],
updatePositions(),
mainTowerHP := mainTowerHP - CIRCLE_DAMAGE, 
ReachMainTower = true,
t := 0</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Turret</name>
		<parameter>int &amp;range, int &amp;rof, int &amp;atk, int x, int y, int id</parameter>
		<declaration>int[0, NUM_SQUARES+NUM_CIRCLES-1] target_id; //the number of targets

bool present; //true if a suitable target was found, false otherwise
bool shot; //true if the turret has fired and needs to reload

clock turret_clock; //turret internal clock

//local functions
/*bool find_target(int range, int rof, int x, int y){
    bool found= false;
    int r;
    int i;
    int j;
    int current_id = -1;
    int current_time;
    int best_id = -1;
    int best_time;

    r = 1;

    while (r &lt;= range &amp;&amp; !found) {
        // Left and right columns
        for (j = y-r; j &lt;= y+r; j++){
            if(x-r &gt;= 0 &amp;&amp; j&gt;=0 &amp;&amp; j &lt; WIDTH){
                    i = x-r;
                    //if the coordinate is a path
                    if(map[i][j] == PATH){
                        current_id = id_inMap[i][j];
                        //if there is an enemy --&gt; different from -1
                        //and if the enemy is alive (health of the enemy is greater than 0)
                        if(current_id != -1 &amp;&amp; ((current_id &lt; NUM_SQUARES &amp;&amp; square_health[current_id] &gt; 0) || (current_id &gt;= NUM_SQUARES &amp;&amp; circle_health[current_id - NUM_SQUARES] &gt; 0))){
                            current_time = activation_order[current_id];
                            if(!found || current_time &lt; best_time || (current_time == best_time &amp;&amp; current_id &gt;= 0 &amp;&amp; current_id &lt;= (NUM_SQUARES-1) &amp;&amp; !(best_id &gt;= 0 &amp;&amp; best_id &lt;= (NUM_SQUARES-1)))){
                                found = true;
                                best_id = current_id;
                                best_time = current_time;
                        }
                    }
                    
                }                        
            }
             
            if(x+r &lt; WIDTH &amp;&amp; j&gt;=0 &amp;&amp; j &lt; HEIGHT){
                i = x+r;
                //if the coordinate is a path
                if(map[i][j] == PATH){
                    current_id = id_inMap[i][j];
                    //if there is an enemy --&gt; different from -1
                    //and if the enemy is alive (health of the enemy is greater than 0)
                    if(current_id != -1 &amp;&amp; ((current_id &lt; NUM_SQUARES &amp;&amp; square_health[current_id] &gt; 0) || (current_id &gt;= NUM_SQUARES &amp;&amp; circle_health[current_id - NUM_SQUARES] &gt; 0))){
                        current_time = activation_order[current_id];
                        if(!found || current_time &lt; best_time || (current_time == best_time &amp;&amp; current_id &gt;= 0 &amp;&amp; current_id &lt;= (NUM_SQUARES-1) &amp;&amp; !(best_id &gt;= 0 &amp;&amp; best_id &lt;= (NUM_SQUARES-1)))){
                            found = true;
                            best_id = current_id;
                            best_time = current_time;
                        }
                    }
                    
                } 
            }
                
        }

    // Top and bottom rows (excluding corners)
    for(i = x-r+1; i &lt;= x+r-1; i++){
			if(i &gt;= 0 &amp;&amp; i &lt; WIDTH){
                //top
				if( y-r &gt;=0){
                    j = y-r;
                    //if the coordinate is a path
                    if(map[i][j] == PATH){
                        current_id = id_inMap[i][j];
                       //if there is an enemy --&gt; different from -1
                       //and if the enemy is alive (health of the enemy is greater than 0)
                       if(current_id != -1 &amp;&amp; ((current_id &lt; NUM_SQUARES &amp;&amp; square_health[current_id] &gt; 0) || (current_id &gt;= NUM_SQUARES &amp;&amp; circle_health[current_id - NUM_SQUARES] &gt; 0))){
                            current_time = activation_order[current_id];
                            if(!found || current_time &lt; best_time || (current_time == best_time &amp;&amp; current_id &gt;= 0 &amp;&amp; current_id &lt;= (NUM_SQUARES-1) &amp;&amp; !(best_id &gt;= 0 &amp;&amp; best_id &lt;= (NUM_SQUARES-1)))){
                                found = true;
                                best_id = current_id;
                                best_time = current_time;
                            }
                        }
                    
                    }   
                }
                //bottom
				if(y+r &lt; HEIGHT){
                    j = y+r;
                    //if the coordinate is a path
                    if(map[i][j] == PATH){
                        current_id = id_inMap[i][j];
                        //if there is an enemy --&gt; different from -1
                        //and if the enemy is alive (health of the enemy is greater than 0)
                        if(current_id != -1 &amp;&amp; ((current_id &lt; NUM_SQUARES &amp;&amp; square_health[current_id] &gt; 0) || (current_id &gt;= NUM_SQUARES &amp;&amp; circle_health[current_id - NUM_SQUARES] &gt; 0))){
                            current_time = activation_order[current_id];
                            if(!found || current_time &lt; best_time || (current_time == best_time &amp;&amp; current_id &gt;= 0 &amp;&amp; current_id &lt;= (NUM_SQUARES-1) &amp;&amp; !(best_id &gt;= 0 &amp;&amp; best_id &lt;= (NUM_SQUARES-1)))){
                                found = true;
                                best_id = current_id;
                                best_time = current_time;
                            }
                        }                   
                    }
                }					
			}
		}

        if (found) {
            output_id = best_id;
        } else {
            r++;
        }
    }
    return found;
}*/

/**
* Returns the absolute value
* @param v    Input number
* @return     Absolute value of the input number
*/
int abs_val(int v) {
    return (v &lt; 0) ? -v : v;
}

/**
* Returns chebyshev distance
* @param x        Enemy x-coordinate
* @param y        Enemy y-coordinate
* @param tur_x    Turret x-coordinate
* @param tur_y    Turret y-coordinate
* @return         Chebyshev distance
*/
int chebyshev_distance(int x, int y, int tur_x, int tur_y) {
    int dx = abs_val(x - tur_x);
    int dy = abs_val(y - tur_y);
    return (dx &gt; dy) ? dx : dy;
}

/**
* Evaluates to true if a suitable target was found, the target's id is also saved
* @param r    The turret range
* @param rof  The rate of fire
* @param x    Position of turret coordinate
* @param y    Position of turret coordinate
* @return     true if a target was found, false otherwise
*/
bool find_target(int r, int rof, int x, int y){
    //scroll through square
    //scroll through circle
    bool found, square;
    int i,j;
    int min_distance, current_distance;
    int min_id; 
    int min_time;
    int current_time;
    
    square = false;
    
    for (i = 0; i &lt; NUM_SQUARES; i++){
        if(sqrs_pos[i][0] &gt; -1 &amp;&amp; sqrs_pos[i][1] &gt; -1 &amp;&amp; square_health[i] &gt;0){
            if (abs_val(sqrs_pos[i][0] - x) &lt;= r &amp;&amp; abs_val(sqrs_pos[i][1] - y) &lt;= r) {
                // within Chebyshev range
                
                current_distance = chebyshev_distance(sqrs_pos[i][0], sqrs_pos[i][1], x, y);
                if (!found){
                    found = true;
                    square = true;
                    min_distance = current_distance;
                    min_id = i;
                    min_time = activation_order[i];
                } else {
                    if(current_distance &lt; min_distance){
                        min_distance = current_distance;
                        min_id = i;
                        min_time = activation_order[i];
                    } else if(current_distance == min_distance){
                        current_time = activation_order[i];
                        if(current_time &gt; min_time){
                            min_distance = current_distance;
                            min_id = i;
                            min_time = activation_order[i];
                        }
                    }
                }
            }
        }
    }
    
    for (j=0; j &lt; NUM_CIRCLES; j++){
        if(circles_pos[j][0] &gt; -1 &amp;&amp; circles_pos[j][1] &gt; -1 &amp;&amp; circle_health[j] &gt; 0){
            if (abs_val(circles_pos[j][0] - x) &lt;= r &amp;&amp; abs_val(circles_pos[j][1] - y) &lt;= r) {
                // within Chebyshev range
                current_distance = chebyshev_distance(circles_pos[j][0], circles_pos[j][1], x, y);
                if (!found){
                    found = true;             
                    min_distance = current_distance;
                    min_id = j;
                    min_time = activation_order[j+NUM_SQUARES];
                } else {
                    if(current_distance &lt; min_distance){
                        square = false;
                        min_distance = current_distance;
                        min_id = j;
                        min_time = activation_order[j+NUM_SQUARES];
                    } else if(current_distance == min_distance){
                        if(!square){
                            current_time = activation_order[j+NUM_SQUARES];
                            if(current_time &gt; min_time){
                                min_distance = current_distance;
                                min_id = j;
                                min_time = activation_order[j+NUM_SQUARES];
                            }
                        }
                    }
                }
            }
        }
    }

    if(found){
        target_id = (square) ? min_id : min_id + NUM_SQUARES;
    }

    return found;
}
</declaration>
		<location id="id61" x="-3646" y="-1190">
			<name x="-3663" y="-1224">idle</name>
		</location>
		<location id="id62" x="-3060" y="-1190">
			<name x="-3102" y="-1224">ready_to_fire</name>
			<committed/>
		</location>
		<location id="id63" x="-2584" y="-1190">
			<name x="-2610" y="-1224">reload</name>
			<label kind="exponentialrate" x="-2609" y="-1173">1 : rof</label>
		</location>
		<location id="id64" x="-3060" y="-977">
			<name x="-3070" y="-1011">End</name>
		</location>
		<init ref="id61"/>
		<transition id="id65">
			<source ref="id63"/>
			<target ref="id62"/>
			<label kind="guard" x="-2983" y="-1351">turret_clock &gt;=rof</label>
			<label kind="assignment" x="-2983" y="-1334">shot := false,
present := find_target(range, rof, x, y)</label>
			<nail x="-2584" y="-1292"/>
			<nail x="-3060" y="-1292"/>
		</transition>
		<transition id="id66">
			<source ref="id61"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-3586" y="-977">end_all?</label>
			<nail x="-3646" y="-986"/>
		</transition>
		<transition id="id67">
			<source ref="id63"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-2873" y="-1028">end_all?</label>
		</transition>
		<transition id="id68">
			<source ref="id62"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-3128" y="-1105">end_all?</label>
		</transition>
		<transition id="id69">
			<source ref="id62"/>
			<target ref="id61"/>
			<label kind="guard" x="-3459" y="-1249">!present</label>
			<nail x="-3417" y="-1224"/>
			<nail x="-3417" y="-1224"/>
		</transition>
		<transition id="id70">
			<source ref="id62"/>
			<target ref="id63"/>
			<label kind="guard" x="-2881" y="-1215">present</label>
			<label kind="assignment" x="-2958" y="-1181">apply_damage(target_id, atk),
turret_clock := 0,
shot := true</label>
			<nail x="-2813" y="-1190"/>
		</transition>
		<transition id="id71">
			<source ref="id61"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-3604" y="-1147">turret_notify?</label>
			<label kind="assignment" x="-3604" y="-1190">present = find_target(range, rof, x, y),
shot := false</label>
		</transition>
	</template>
	<system>// Place template instantiations here.

M = Map();
T(const id_t id) = Turret(ranges[id], rofs[id], atks[id], locations[id].x, locations[id].y , id);
S(const id_s id) = EnemySquare(id);
C(const id_c id) = EnemyCircle(id);
// List one or more processes to be composed into a system.
system S, C, M, T;</system>
	<queries>
		<query>
			<formula>simulate [&lt;=200; 10] { globalClock, mainTowerHP }</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-07-20 13:31:58 +0200">
				<plot title="Simulations (10)" xaxis="time" yaxis="value">
					<series title="globalClock" type="l" color="0xff0000" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff0909" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff1212" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff1b1b" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff2424" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff2d2d" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff3636" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff3e3e" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff4747" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="" type="l" color="0xff5050" encoding="csv">0.0,0.0
200.000002,200.000002
					</series>
					<series title="mainTowerHP" type="l" color="0x00ffff" encoding="csv">0.0,100.0
153.68946298785744,100.0
153.68946298785744,96.0
155.97063455681433,96.0
156.00989832274576,92.0
167.34071726048393,92.0
167.35815744505604,88.0
172.46347991021852,88.0
172.5093631937628,84.0
177.4674385670574,84.0
177.4674385670574,80.0
178.8950458844276,80.0
178.94028337765548,76.0
180.0250475401792,76.0
180.03577804597933,72.0
181.61258697481983,72.0
181.63523663471182,68.0
184.6622983808734,68.0
184.6622983808734,64.0
194.66113046869424,64.0
194.67320979965382,60.0
196.9941363901281,60.0
196.9941363901281,56.0
198.32154734669584,56.0
198.32154734669584,52.0
200.000002,52.0
					</series>
					<series title="" type="l" color="0x09ffff" encoding="csv">0.0,100.0
165.21307198278728,100.0
165.2272227774664,96.0
165.76083017754246,96.0
165.76083017754246,92.0
171.3473440131456,92.0
171.38700924225148,88.0
180.83075377023084,88.0
180.86935073113926,84.0
181.47350336785826,84.0
181.47350336785826,80.0
185.77721873109232,80.0
185.81800846743462,76.0
187.86421195389764,76.0
187.89434788061754,72.0
197.0267864795727,72.0
197.0267864795727,68.0
200.000002,68.0
					</series>
					<series title="" type="l" color="0x12ffff" encoding="csv">0.0,100.0
160.6998804073213,100.0
160.70718885307838,96.0
165.68433265976392,96.0
165.68433265976392,92.0
167.16114360284942,92.0
167.19940815089365,88.0
167.97995607494215,88.0
168.02562130179,84.0
172.71258238035765,84.0
172.71258238035765,80.0
174.71726857105358,80.0
174.71726857105358,76.0
175.77265158795356,76.0
175.81740345716324,72.0
177.7205253075405,72.0
177.7310280003681,68.0
193.4259653077142,68.0
193.4259653077142,64.0
197.242446934356,64.0
197.25633471890458,60.0
200.000002,60.0
					</series>
					<series title="" type="l" color="0x1bffff" encoding="csv">0.0,100.0
150.01194282389764,100.0
150.01194282389764,96.0
161.57337950022213,96.0
161.60108443198214,92.0
169.40176843081542,92.0
169.40176843081542,88.0
174.25685931492163,88.0
174.25685931492163,84.0
183.2425238794461,84.0
183.28545044890018,80.0
185.18453883036165,80.0
185.22642915068735,76.0
187.64896954942907,76.0
187.64896954942907,72.0
189.33314955075346,72.0
189.33314955075346,68.0
196.01641983351655,68.0
196.01641983351655,64.0
196.64484342646577,64.0
196.66967405595793,60.0
198.889326187781,60.0
198.90251870122924,56.0
200.000002,56.0
					</series>
					<series title="" type="l" color="0x24ffff" encoding="csv">0.0,100.0
176.2978985041157,100.0
176.3396278186126,96.0
184.89772594449207,96.0
184.90019524117398,92.0
187.33109358212133,92.0
187.37994324557803,88.0
190.53032168212926,88.0
190.53494887176674,84.0
193.11568436312245,84.0
193.15708807812305,80.0
194.50760402317377,80.0
194.54475548501506,78.0
195.55528234766962,78.0
195.5717458937633,74.0
200.000002,74.0
					</series>
					<series title="" type="l" color="0x2dffff" encoding="csv">0.0,100.0
178.65522370985266,100.0
178.6763257680373,96.0
178.96858443403718,96.0
178.96858443403718,92.0
182.34163279597723,92.0
182.34163279597723,88.0
184.78953795572545,88.0
184.78953795572545,84.0
189.31363325582402,84.0
189.33209733640172,80.0
189.4169603798374,80.0
189.4169603798374,76.0
192.1486387029145,76.0
192.18017402195858,72.0
193.34271977134014,72.0
193.35594854208014,68.0
197.89207704490877,68.0
197.9223488323431,64.0
200.000002,64.0
					</series>
					<series title="" type="l" color="0x36ffff" encoding="csv">0.0,100.0
171.00752078357868,100.0
171.00752078357868,96.0
172.54940814488214,96.0
172.54940814488214,92.0
173.31813774290362,92.0
173.35365472482968,88.0
174.12220643467717,88.0
174.1612965627437,84.0
183.76798578923942,84.0
183.76798578923942,80.0
184.67811972568393,80.0
184.67811972568393,76.0
185.0526416786795,76.0
185.0526416786795,72.0
187.09064580543037,72.0
187.11008874288606,68.0
195.9758638713716,68.0
196.0,64.0
198.79675479032002,64.0
198.79675479032002,62.0
200.000002,62.0
					</series>
					<series title="" type="l" color="0x3effff" encoding="csv">0.0,100.0
168.67864134406852,100.0
168.715296111824,96.0
169.83141090088915,96.0
169.86919663270083,92.0
170.015975715178,92.0
170.0218733840587,88.0
170.17828042612476,88.0
170.17828042612476,84.0
170.6074946229064,84.0
170.6074946229064,80.0
180.0053718911911,80.0
180.0053718911911,76.0
182.9521385266873,76.0
183.0,72.0
188.80288125099182,72.0
188.80288125099182,70.0
193.78802150092457,70.0
193.78802150092457,66.0
194.06504676519512,66.0
194.06504676519512,62.0
194.98480627935686,62.0
195.02609018370796,58.0
200.000002,58.0
					</series>
					<series title="" type="l" color="0x47ffff" encoding="csv">0.0,100.0
149.5892914916837,100.0
149.5892914916837,96.0
153.99284208720022,96.0
154.0,92.0
157.01321404633197,92.0
157.03194649146235,88.0
160.82094444150067,88.0
160.82094444150067,84.0
168.87388582737316,84.0
168.90104285339137,80.0
178.23586945543022,80.0
178.28353619756768,76.0
179.8252555143269,76.0
179.83079314894948,72.0
183.75838178471213,72.0
183.75838178471213,68.0
186.66609529127857,68.0
186.66609529127857,64.0
193.35206675958048,64.0
193.35206675958048,60.0
193.81448083600182,60.0
193.81448083600182,56.0
196.90251599426261,56.0
196.90251599426261,52.0
200.000002,52.0
					</series>
					<series title="" type="l" color="0x50ffff" encoding="csv">0.0,100.0
156.86541575273782,100.0
156.86541575273782,96.0
162.71906273476964,96.0
162.725763226402,92.0
164.05091207540724,92.0
164.05091207540724,88.0
178.35744224030498,88.0
178.35744224030498,84.0
180.87335764750514,84.0
180.890490921464,80.0
185.0399486849728,80.0
185.0399486849728,76.0
200.000002,76.0
					</series>
					<comment/>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=200] ([] mainTowerHP == 100)</formula>
			<comment/>
			<result outcome="success" type="interval" value="≤ 0.0499441 (95% CI)" timestamp="2025-07-20 13:35:10 +0200">
				<details>≤ 0.0499441 (95% CI)</details>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=400] (&lt;&gt; mainTowerHP &lt;= 0)</formula>
			<comment>configuration II : all snipers in position {2,3}, {5,5}, {8,2}, {8,6}, {11,5}, {14,2}, {14,6}, up to 400 time units --&gt; high probability that eventually the mainTower would fall (HP &lt;= 0)</comment>
			<result outcome="success" type="interval" value="≥ 0.950056 (95% CI)" timestamp="2025-07-20 12:23:04 +0200">
				<details>≥ 0.950056 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="run duration in time" yaxis="probability density">
					<series title="density" type="b(5.309053)" color="0x0000ff" encoding="csv">288.2320320904955,0.013080382601884348
293.5410850867313,0.013080382601884348
298.8501380829671,0.020928612163014955
304.15919107920286,0.034008994764899304
309.46824407543863,0.034008994764899304
314.7772970716744,0.04185722432602991
320.0863500679102,0.015696459122261218
325.39540306414597,0.010464306081507477
330.70445606038174,0.005232153040753739
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">311.062182448645,0.0
311.062182448645,0.04185722432602991
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=5.3091, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [288.23, 336.01]
Mean estimate of displayed sample: 311.06 ± 2.3962 (95% CI)</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="run duration in time" yaxis="probability density">
					<series title="upper limit" type="b(5.309053)" color="0xa0a0ff" encoding="csv">288.2320320904955,0.15466731481612306
293.5410850867313,0.15466731481612306
298.8501380829671,0.20724687066674882
304.15919107920286,0.2889434084029285
309.46824407543863,0.2889434084029285
314.7772970716744,0.3356366278546927
320.0863500679102,0.172608584683674
325.39540306414597,0.13617864931292403
330.70445606038174,0.09676728911341523
					</series>
					<series title="lower limit" type="b(5.309053)" color="0x0000ff" encoding="csv">288.2320320904955,0.022931659153745478
293.5410850867313,0.022931659153745478
298.8501380829671,0.04920803927064098
304.15919107920286,0.09979350815289616
309.46824407543863,0.09979350815289616
314.7772970716744,0.1326823847878405
320.0863500679102,0.031197509141384482
325.39540306414597,0.015342537111130598
330.70445606038174,0.0033819003261732383
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">311.062182448645,0.0
311.062182448645,0.06321967930865742
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=5.3091, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [288.23, 336.01]
Mean estimate of displayed sample: 311.06 ± 2.3962 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="probability" type="b(5.309053)" color="0x0000ff" encoding="csv">288.2320320904955,0.06944444444444445
293.5410850867313,0.06944444444444445
298.8501380829671,0.1111111111111111
304.15919107920286,0.18055555555555555
309.46824407543863,0.18055555555555555
314.7772970716744,0.2222222222222222
320.0863500679102,0.08333333333333333
325.39540306414597,0.05555555555555555
330.70445606038174,0.027777777777777776
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">311.062182448645,0.0
311.062182448645,0.2222222222222222
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=5.3091, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [288.23, 336.01]
Mean estimate of displayed sample: 311.06 ± 2.3962 (95% CI)</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="b(5.309053)" color="0xa0a0ff" encoding="csv">288.2320320904955,0.15466731481612306
293.5410850867313,0.15466731481612306
298.8501380829671,0.20724687066674882
304.15919107920286,0.2889434084029285
309.46824407543863,0.2889434084029285
314.7772970716744,0.3356366278546927
320.0863500679102,0.172608584683674
325.39540306414597,0.13617864931292403
330.70445606038174,0.09676728911341523
					</series>
					<series title="lower limit" type="b(5.309053)" color="0x0000ff" encoding="csv">288.2320320904955,0.022931659153745478
293.5410850867313,0.022931659153745478
298.8501380829671,0.04920803927064098
304.15919107920286,0.09979350815289616
309.46824407543863,0.09979350815289616
314.7772970716744,0.1326823847878405
320.0863500679102,0.031197509141384482
325.39540306414597,0.015342537111130598
330.70445606038174,0.0033819003261732383
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">311.062182448645,0.0
311.062182448645,0.3356366278546927
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=5.3091, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [288.23, 336.01]
Mean estimate of displayed sample: 311.06 ± 2.3962 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">288.2320320904955,0.0
293.5410850867313,0.06944444444444445
298.8501380829671,0.1388888888888889
304.15919107920286,0.25
309.46824407543863,0.4305555555555556
314.7772970716744,0.6111111111111112
320.0863500679102,0.8333333333333334
325.39540306414597,0.9166666666666666
330.70445606038174,0.9722222222222222
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">311.062182448645,0.0
311.062182448645,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=5.3091, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [288.23, 336.01]
Mean estimate of displayed sample: 311.06 ± 2.3962 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">288.2320320904955,0.04994408370585468
293.5410850867313,0.15466731481612306
298.8501380829671,0.24062593250302433
304.15919107920286,0.3660280721379009
309.46824407543863,0.5526642096839557
314.7772970716744,0.7238453141525445
320.0863500679102,0.910803593991874
325.39540306414597,0.9688024908586155
330.70445606038174,0.9966180996738268
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">288.2320320904955,0.0
293.5410850867313,0.022931659153745478
298.8501380829671,0.06866420769681664
304.15919107920286,0.15539265735437505
309.46824407543863,0.3143406522440227
314.7772970716744,0.48893693622768925
320.0863500679102,0.7269607210880693
325.39540306414597,0.827391415316326
330.70445606038174,0.9032327108865847
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">288.2320320904955,0.0
293.5410850867313,0.06944444444444445
298.8501380829671,0.1388888888888889
304.15919107920286,0.25
309.46824407543863,0.4305555555555556
314.7772970716744,0.6111111111111112
320.0863500679102,0.8333333333333334
325.39540306414597,0.9166666666666666
330.70445606038174,0.9722222222222222
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">311.062182448645,0.0
311.062182448645,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=5.3091, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [288.23, 336.01]
Mean estimate of displayed sample: 311.06 ± 2.3962 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="run duration in time" yaxis="count">
					<series title="count" type="b(5.309053)" color="0x0000ff" encoding="csv">288.2320320904955,5.0
293.5410850867313,5.0
298.8501380829671,8.0
304.15919107920286,13.0
309.46824407543863,13.0
314.7772970716744,16.0
320.0863500679102,6.0
325.39540306414597,4.0
330.70445606038174,2.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">311.062182448645,0.0
311.062182448645,16.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=5.3091, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [288.23, 336.01]
Mean estimate of displayed sample: 311.06 ± 2.3962 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=200] (&lt;&gt; mainTowerHP &lt;= 0)</formula>
			<comment>configuration III : cannon cluster in positions  {5,5}, {8,2}, {8,6}, {11,5}, {14,2}, up to 200 time units </comment>
			<result outcome="success" type="interval" value="≤ 0.0499441 (95% CI)" timestamp="2025-07-20 14:05:06 +0200">
				<details>≤ 0.0499441 (95% CI)</details>
			</result>
		</query>
	</queries>
</nta>
