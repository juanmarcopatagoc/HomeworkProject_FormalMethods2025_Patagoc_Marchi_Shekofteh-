<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// === Game Parameters ===
const int WIDTH = 16;
const int HEIGHT = 8;
const int MAP_SIZE = WIDTH * HEIGHT;

// === CHANNELS ===
chan attack;
chan movement;
broadcast chan turret_notify;


// === Turrets Parameters ===

//Turrets
const int NUM_TURRETS = 7;

//Turrets Damage
const int SNIPER_ATK = 20;
const int CANNON_ATK = 5;
const int BASIC_ATK = 2;

//Turrets Range
const int SNIPER_RANGE = 4;
const int CANNON_RANGE = 1;
const int BASIC_RANGE = 2;

//Turrets Rate of Fire
const int SNIPER_ROF = 20;
const int CANNON_ROF = 7;
const int BASIC_ROF = 2;

//Turrets state arrays;
typedef int[0, NUM_TURRETS-1] id_t;
chan shoot[id_t];
int ranges[id_t] = {BASIC_RANGE, BASIC_RANGE,BASIC_RANGE,BASIC_RANGE,BASIC_RANGE,BASIC_RANGE,BASIC_RANGE};
int rofs[id_t] = {BASIC_ROF,BASIC_ROF,BASIC_ROF,BASIC_ROF,BASIC_ROF,BASIC_ROF,BASIC_ROF};
int atks[id_t] = {BASIC_ATK,BASIC_ATK,BASIC_ATK,BASIC_ATK,BASIC_ATK,BASIC_ATK,BASIC_ATK};
int locations[id_t][2] = {{2,3}, {5,5}, {8,2}, {8,6}, {11,5}, {14,2}, {14,6}};

// === Enemies Parameters ===

// Enemies
const int NUM_CIRCLES = 3;
const int NUM_SQUARES = 3;

//Enemies Speeds
const int CIRCLE_SPEED = 1;
const int SQUARE_SPEED = 3;

//Enemies Health
const int CIRCLE_HEALTH = 10;
const int SQUARE_HEALTH = 20;

//Enenmies Damage
const int CIRCLE_DAMAGE = 2;
const int SQUARE_DAMAGE = 4;

//Enenmies Spawning
const int CIRCLE_SPAWN_INTERVAL = 2;
const int SQUARE_SPAWN_INTERVAL = 3;

// Enemy position variables
int START_X = 0;
int START_Y = 0;

int sqrs_pos[NUM_SQUARES][2];
int circles_pos[NUM_CIRCLES][2];

// Main Tower
int mainTowerHP = 10;

// Enemy state arrays
int circle_health[NUM_CIRCLES];
bool circle_alive[NUM_CIRCLES];

int square_health[NUM_SQUARES];
bool square_alive[NUM_SQUARES];

//to save when the enemy instance has started
int activation_order[NUM_SQUARES+NUM_CIRCLES];
int activation_counter = 0;
// Clock for simulation
clock globalClock;



// Cell types
const int WALL = 0;
const int PATH = 1;
const int TURRET = 2;
const int ENTRY = 3;
const int MAIN = 4;
const int SQUARE = 5;
const int CIRCLE = 6;

// Main Tower position
const int MAIN_X = 15;
const int MAIN_Y = 4;

// Bifurcation points
const int BIFURCATION1_X = 7;
const int BIFURCATION1_Y = 4;
const int BIFURCATION2_X = 10;
const int BIFURCATION2_Y = 7;

int map[HEIGHT][WIDTH] = {
//x= 0     1     2       3     4     5       6     7       8       9     10    11      12    13    14      15
    {PATH, 0,    0,      0,    0,    0,      0,    0,      0,      0,    0,    0,      0,    0,    0,      0},    // y = 0
    {PATH, 0,    0,      0,    0,    0,      0,    PATH,   PATH,   PATH, PATH, PATH,   PATH, PATH, PATH,   PATH}, // y = 1
    {PATH, 0,    0,      0,    0,    0,      0,    PATH,   TURRET, 0,    0,    0,      0,    0,    TURRET, PATH}, // y = 2
    {PATH, 0,    TURRET, 0,    0,    0,      0,    PATH,   0,      0,    0,    0,      0,    0,    0,      PATH}, // y = 3
    {PATH, PATH, PATH,   PATH, PATH, PATH,   PATH, PATH,   0,      0,    PATH, PATH,   PATH, PATH, PATH,   PATH}, // y = 4
    {0,    0,    0,      0,    0,    TURRET, 0,    PATH,   0,      0,    PATH, TURRET, 0,    0,    0,      PATH}, // y = 5
    {0,    0,    0,      0,    0,    0,      0,    PATH,   TURRET, 0,    PATH, 0,      0,    0,    TURRET, PATH}, // y = 6
    {0,    0,    0,      0,    0,    0,      0,    PATH,   PATH,   PATH, PATH, PATH,   PATH, PATH, PATH,   PATH}  // y = 7
};

/*int id_inMap[HEIGHT][WIDTH] = {
//x= 0     1     2       3     4     5       6     7       8       9     10    11      12    13    14      15
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 0
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 1
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 2
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 3
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 4
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 5
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}, // y = 6
    {-1, -1,    -1,      -1,    -1,    -1,      -1,    -1,      -1,      -1,    -1,    -1,      -1,    -1,    -1,      -1}  // y = 7
};*/


//appling damage to the enemy target function
void apply_damage(int target_id, int dmg) {
    if (target_id &lt; NUM_SQUARES)
        square_health[target_id] -= dmg;
    else
        circle_health[target_id - NUM_SQUARES] -= dmg;
}



</declaration>
	<template>
		<name>Map</name>
		<location id="id0" x="-646" y="-187">
			<name x="-656" y="-221">Idle</name>
		</location>
		<location id="id1" x="-459" y="-187">
			<name x="-469" y="-221">GameOver</name>
		</location>
		<location id="id2" x="-799" y="-187">
			<urgent/>
		</location>
		<init ref="id0"/>
		<transition id="id3">
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-782" y="-127">turret_notify!</label>
			<nail x="-731" y="-127"/>
		</transition>
		<transition id="id4">
			<source ref="id0"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-765" y="-204">movement?</label>
		</transition>
		<transition id="id5">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="-612" y="-204">mainTowerHP==0</label>
		</transition>
		<transition id="id6">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-671" y="-323">attack?</label>
			<nail x="-731" y="-305"/>
			<nail x="-561" y="-305"/>
		</transition>
	</template>
	<template>
		<name>EnemySquare</name>
		<parameter>int id</parameter>
		<declaration>clock t;
int x = 0;
int y = 0;
int prev_x = -1;
int prev_y = -1;
bool bifurcation;

int next[2][2] = {
    {-1, -1},
    {-1, -1}
}; // Array of possible next [x,y] positions


void updatePositions(){
    sqrs_pos[id][0] = x;
    sqrs_pos[id][1] = y;
}


void initializePositions(){
    sqrs_pos[id][0] = -1;
    sqrs_pos[id][1] = -1;
}



// Returns possible next positions from (x,y)
void getNextPositions(int x, int y, int prev_x, int prev_y) {
    
    next[0][0] = -1;
    next[0][1] = -1;
    next[1][0] = -1;
    next[1][1] = -1;
    bifurcation = false;
     
    // Main Tower reached - no further movement
    if(x == MAIN_X &amp;&amp; y == MAIN_Y) {
        return;
    }
    
    // Bifurcation point 1
    if(x == BIFURCATION1_X &amp;&amp; y == BIFURCATION1_Y) {
        // Move up
        next[0][0] = x;
        next[0][1] = y+1;
         // Move down
        next[1][0] = x;
        next[1][1] = y-1;
        bifurcation = true;
        return;
    }
    
    // Bifurcation point 2
    if(x == BIFURCATION2_X &amp;&amp; y == BIFURCATION2_Y) {
        // Move down
        next[0][0] = x;
        next[0][1] = y-1;
        // Move right
        next[1][0] = x+1;
        next[1][1] = y;
        bifurcation = true;
        return;
    }
    
    // Horizontal movement
    if (x+1 != prev_x || y != prev_y){
        if (x &lt; WIDTH - 1 &amp;&amp; map[y][x + 1] == PATH) {
            next[0][0] = x + 1;
            next[0][1] = y;
            return;
        }
    }
    // Vertical movement
    if (y &lt; HEIGHT - 1 &amp;&amp; map[y + 1][x] == PATH &amp;&amp; !(x == prev_x &amp;&amp; y+1 == prev_y)) {
        next[0][0] = x;
        next[0][1] = y + 1;
        return;
    }
    if (y &gt; 0 &amp;&amp; map[y - 1][x] == PATH &amp;&amp; !(x == prev_x &amp;&amp; y-1 == prev_y)) {
        next[0][0] = x;
        next[0][1] = y - 1;
        return;
    }
    // Edge case handling
    return ;
}</declaration>
		<location id="id7" x="-2031" y="-1181">
			<name x="-2048" y="-1215">Spawn</name>
			<label kind="invariant" x="-2091" y="-1164">t&lt;=SQUARE_SPAWN_INTERVAL*(id+1)</label>
		</location>
		<location id="id8" x="-884" y="-739">
			<name x="-894" y="-773">Decide</name>
			<urgent/>
		</location>
		<location id="id9" x="-340" y="-739">
			<name x="-350" y="-773">Attack</name>
			<label kind="invariant" x="-399" y="-722">t&lt;=SQUARE_SPEED</label>
		</location>
		<location id="id10" x="-612" y="-739">
			<name x="-622" y="-773">Leave</name>
		</location>
		<location id="id11" x="-1487" y="-739">
			<name x="-1538" y="-773">Move_bifurcation</name>
			<label kind="invariant" x="-1496" y="-722">t&lt;=SQUARE_SPEED</label>
			<label kind="testcodeEnter">getNextPositions(x, y);</label>
		</location>
		<location id="id12" x="-1487" y="-1181">
			<urgent/>
		</location>
		<location id="id13" x="-884" y="-1181">
			<name x="-894" y="-1215">Move</name>
			<label kind="invariant" x="-935" y="-1173">t&lt;=SQUARE_SPEED</label>
		</location>
		<location id="id14" x="-884" y="-1436">
			<label kind="invariant" x="-935" y="-1479">t&lt;=SQUARE_SPEED</label>
		</location>
		<init ref="id7"/>
		<transition id="id15">
			<source ref="id12"/>
			<target ref="id14"/>
			<label kind="guard" x="-1615" y="-1351">next[0][0] == MAIN_X &amp;&amp; next[0][1] == MAIN_Y</label>
			<nail x="-1487" y="-1436"/>
		</transition>
		<transition id="id16">
			<source ref="id13"/>
			<target ref="id8"/>
			<label kind="guard" x="-875" y="-1105">t &gt;= SQUARE_SPEED &amp;&amp;
next[0][0] != -1 &amp;&amp; 
next[0][1] != -1</label>
			<label kind="synchronisation" x="-875" y="-901">movement!</label>
			<label kind="assignment" x="-875" y="-1054">prev_x = x, 
prev_y = y,
x = next[0][0], 
y = next[0][1],
updatePositions(),
t := 0</label>
		</transition>
		<transition id="id17">
			<source ref="id12"/>
			<target ref="id11"/>
			<label kind="guard" x="-1530" y="-969">bifurcation</label>
		</transition>
		<transition id="id18">
			<source ref="id12"/>
			<target ref="id13"/>
			<label kind="guard" x="-1428" y="-1207">!bifurcation &amp;&amp; (next[0][0] != MAIN_X || next[0][1] != MAIN_Y)</label>
		</transition>
		<transition id="id19">
			<source ref="id8"/>
			<target ref="id10"/>
			<label kind="guard" x="-850" y="-739">square_health[id] &lt;= 0</label>
			<label kind="assignment" x="-858" y="-714">square_alive[id] := false</label>
		</transition>
		<transition id="id20">
			<source ref="id8"/>
			<target ref="id12"/>
			<label kind="guard" x="-1275" y="-1037">square_alive[id] == true</label>
			<label kind="assignment" x="-1266" y="-1020">getNextPositions(x, y, prev_x, prev_y),
t:=0</label>
		</transition>
		<transition id="id21">
			<source ref="id11"/>
			<target ref="id8"/>
			<label kind="select" x="-1275" y="-731">i : int[0,1]</label>
			<label kind="guard" x="-1275" y="-714">t &gt;= SQUARE_SPEED &amp;&amp;
next[i][0] != -1 &amp;&amp; 
next[i][1] != -1</label>
			<label kind="synchronisation" x="-1275" y="-493">movement!</label>
			<label kind="assignment" x="-1275" y="-654">prev_x = x, 
prev_y = y,
x = next[i][0], 
y = next[i][1],
updatePositions(),
t := 0</label>
		</transition>
		<transition id="id22">
			<source ref="id7"/>
			<target ref="id12"/>
			<label kind="guard" x="-1844" y="-1164">t &gt;= SQUARE_SPAWN_INTERVAL * (id+1)</label>
			<label kind="assignment" x="-1844" y="-1139">t := 0, 
initializePositions(),
activation_order[id] := activation_counter,
activation_counter++,
square_alive[id] := true, 
square_health[id] := SQUARE_HEALTH,
getNextPositions(x, y, prev_x, prev_y)</label>
		</transition>
		<transition id="id23">
			<source ref="id9"/>
			<target ref="id10"/>
			<label kind="guard" x="-552" y="-739">t &gt;= SQUARE_SPEED</label>
			<label kind="assignment" x="-603" y="-714">square_alive[id] := false,
t := 0</label>
		</transition>
		<transition id="id24">
			<source ref="id14"/>
			<target ref="id9"/>
			<label kind="guard" x="-612" y="-1300">t &gt;= SQUARE_SPEED</label>
			<label kind="synchronisation" x="-612" y="-1105">attack!</label>
			<label kind="assignment" x="-612" y="-1283">prev_x = x,
prev_y = y,
x = next[0][0],
y = next[0][1],
updatePositions(),
mainTowerHP = mainTowerHP-SQUARE_DAMAGE,
t := 0</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">EnemyCircle</name>
		<parameter>int id</parameter>
		<declaration>// Place local declarations here.
clock t;
int x = 0;
int y = 0;
int prev_x = -1;
int prev_y = -1;
bool bifurcation;

int next[2][2] = {
    {-1, -1},
    {-1, -1}
}; // Array of possible next [x,y] positions

void updatePositions(){
    circles_pos[id][0] = x;
    circles_pos[id][1] = y;
}

void initializePositions(){
    circles_pos[id][0] = -1;
    circles_pos[id][1] = -1;
}

// Returns possible next positions from (x,y)
void getNextPositions(int x, int y, int prev_x, int prev_y) {
    
    next[0][0] = -1;
    next[0][1] = -1;
    next[1][0] = -1;
    next[1][1] = -1;
    bifurcation = false;
     
    // Main Tower reached - no further movement
    if(x == MAIN_X &amp;&amp; y == MAIN_Y) {
        return;
    }
    
    // Bifurcation point 1
    if(x == BIFURCATION1_X &amp;&amp; y == BIFURCATION1_Y) {
        // Move up
        next[0][0] = x;
        next[0][1] = y+1;
         // Move down
        next[1][0] = x;
        next[1][1] = y-1;
        bifurcation = true;
        return;
    }
    
    // Bifurcation point 2
    if(x == BIFURCATION2_X &amp;&amp; y == BIFURCATION2_Y) {
        // Move down
        next[0][0] = x;
        next[0][1] = y-1;
        // Move right
        next[1][0] = x+1;
        next[1][1] = y;
        bifurcation = true;
        return;
    }
    
    // Default forward movement
    if (x+1 != prev_x || y != prev_y){
        if (x &lt; WIDTH - 1 &amp;&amp; map[y][x + 1] == PATH) {
            next[0][0] = x + 1;
            next[0][1] = y;
            return;
        }
    }
    // Vertical movement
    if (y &lt; HEIGHT - 1 &amp;&amp; map[y + 1][x] == PATH &amp;&amp; !(x == prev_x &amp;&amp; y+1 == prev_y)) {
        next[0][0] = x;
        next[0][1] = y + 1;
        return;
    }
    if (y &gt; 0 &amp;&amp; map[y - 1][x] == PATH &amp;&amp; !(x == prev_x &amp;&amp; y-1 == prev_y)) {
        next[0][0] = x;
        next[0][1] = y - 1;
        return;
    }
    // Edge case handling
    return ;
}</declaration>
		<location id="id25" x="-1351" y="-323">
			<name x="-1361" y="-357">Spawn</name>
			<label kind="invariant" x="-1445" y="-306">t&lt;=SQUARE_SPAWN_INTERVAL*(id+1)</label>
		</location>
		<location id="id26" x="8" y="194">
			<name x="-2" y="160">decide</name>
			<urgent/>
		</location>
		<location id="id27" x="739" y="195">
			<name x="729" y="161">Attack</name>
		</location>
		<location id="id28" x="212" y="194">
			<name x="202" y="160">Leave</name>
		</location>
		<location id="id29" x="-790" y="194">
			<name x="-935" y="161">Move_bifurcation</name>
			<label kind="invariant" x="-800" y="211">t&lt;=CIRCLE_SPEED</label>
		</location>
		<location id="id30" x="-790" y="-323">
			<urgent/>
		</location>
		<location id="id31" x="8" y="-323">
			<name x="-2" y="-357">Move</name>
			<label kind="invariant" x="-2" y="-306">t&lt;=CIRCLE_SPEED</label>
		</location>
		<location id="id32" x="0" y="-578">
			<label kind="invariant" x="-10" y="-561">t&lt;=CIRCLE_SPEED</label>
		</location>
		<init ref="id25"/>
		<transition id="id33">
			<source ref="id30"/>
			<target ref="id32"/>
			<label kind="guard" x="-772" y="-612">next[0][0] == MAIN_X &amp;&amp; next[0][1] == MAIN_Y</label>
			<nail x="-790" y="-578"/>
		</transition>
		<transition id="id34">
			<source ref="id31"/>
			<target ref="id26"/>
			<label kind="guard" x="17" y="-221">t &gt;= CIRCLE_SPEED &amp;&amp;
next[0][0] != -1 &amp;&amp; 
next[0][1] != -1</label>
			<label kind="synchronisation" x="17" y="-8">movement!</label>
			<label kind="assignment" x="17" y="-170">prev_x = x, 
prev_y = y,
x = next[0][0], 
y = next[0][1],
updatePositions(),
t := 0</label>
		</transition>
		<transition id="id35">
			<source ref="id30"/>
			<target ref="id31"/>
			<label kind="guard" x="-731" y="-340">!bifurcation &amp;&amp; (next[0][0] != MAIN_X || next[0][1] != MAIN_Y)</label>
		</transition>
		<transition id="id36">
			<source ref="id30"/>
			<target ref="id29"/>
			<label kind="guard" x="-790" y="-242">bifurcation</label>
		</transition>
		<transition id="id37">
			<source ref="id26"/>
			<target ref="id28"/>
			<label kind="guard" x="8" y="211">circle_health[id] &lt;= 0</label>
			<label kind="assignment" x="8" y="236">circle_alive[id] := false</label>
		</transition>
		<transition id="id38">
			<source ref="id26"/>
			<target ref="id30"/>
			<label kind="guard" x="-399" y="-187">circle_alive[id] == true</label>
			<label kind="assignment" x="-408" y="-161">getNextPositions(x, y, prev_x, prev_y),
t:=0</label>
		</transition>
		<transition id="id39">
			<source ref="id29"/>
			<target ref="id26"/>
			<label kind="select" x="-459" y="195">i : int[0,1]</label>
			<label kind="guard" x="-459" y="220">t &gt;= CIRCLE_SPEED &amp;&amp;
next[i][0] != -1 &amp;&amp; 
next[i][1] != -1</label>
			<label kind="synchronisation" x="-459" y="442">movement!</label>
			<label kind="assignment" x="-459" y="280">prev_x = x, 
prev_y = y,
x = next[i][0], 
y = next[i][1],
updatePositions(),
t := 0</label>
		</transition>
		<transition id="id40">
			<source ref="id25"/>
			<target ref="id30"/>
			<label kind="guard" x="-1190" y="-324">t &gt;= CIRCLE_SPAWN_INTERVAL * (id+1)</label>
			<label kind="assignment" x="-1190" y="-297">t := 0, 
initializePositions(),
activation_order[id + NUM_SQUARES] := activation_counter,
activation_counter++,
circle_alive[id] := true, 
circle_health[id] := CIRCLE_HEALTH,
getNextPositions(x, y, prev_x, prev_y)</label>
		</transition>
		<transition id="id41">
			<source ref="id27"/>
			<target ref="id28"/>
			<label kind="guard" x="297" y="211">t &gt;= CIRCLE_SPEED</label>
			<label kind="assignment" x="280" y="228">circle_alive[id] := false,
t := 0</label>
		</transition>
		<transition id="id42">
			<source ref="id32"/>
			<target ref="id27"/>
			<label kind="guard" x="459" y="-314">t &gt;= CIRCLE_SPEED</label>
			<label kind="synchronisation" x="459" y="-119">attack!</label>
			<label kind="assignment" x="459" y="-297">prev_x = x,
prev_y = y,
x = next[0][0],
y = next[0][1],
updatePositions(),
mainTowerHP := mainTowerHP - CIRCLE_DAMAGE, 
t := 0</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Turret</name>
		<parameter>int &amp;range, int &amp;rof, int &amp;atk, int &amp;coord[2], int id</parameter>
		<declaration>int[0, NUM_SQUARES+NUM_CIRCLES-1] target_id;
int[0, NUM_SQUARES+NUM_CIRCLES-1] output_id;
int local_value;
bool present;
clock turret_clock;

//local functions
/*bool find_target(int range, int rof, int x, int y){
    bool found= false;
    int r;
    int i;
    int j;
    int current_id = -1;
    int current_time;
    int best_id = -1;
    int best_time;

    r = 1;

    while (r &lt;= range &amp;&amp; !found) {
        // Left and right columns
        for (j = y-r; j &lt;= y+r; j++){
            if(x-r &gt;= 0 &amp;&amp; j&gt;=0 &amp;&amp; j &lt; WIDTH){
                    i = x-r;
                    //if the coordinate is a path
                    if(map[i][j] == PATH){
                        current_id = id_inMap[i][j];
                        //if there is an enemy --&gt; different from -1
                        //and if the enemy is alive (health of the enemy is greater than 0)
                        if(current_id != -1 &amp;&amp; ((current_id &lt; NUM_SQUARES &amp;&amp; square_health[current_id] &gt; 0) || (current_id &gt;= NUM_SQUARES &amp;&amp; circle_health[current_id - NUM_SQUARES] &gt; 0))){
                            current_time = activation_order[current_id];
                            if(!found || current_time &lt; best_time || (current_time == best_time &amp;&amp; current_id &gt;= 0 &amp;&amp; current_id &lt;= (NUM_SQUARES-1) &amp;&amp; !(best_id &gt;= 0 &amp;&amp; best_id &lt;= (NUM_SQUARES-1)))){
                                found = true;
                                best_id = current_id;
                                best_time = current_time;
                        }
                    }
                    
                }                        
            }
             
            if(x+r &lt; WIDTH &amp;&amp; j&gt;=0 &amp;&amp; j &lt; HEIGHT){
                i = x+r;
                //if the coordinate is a path
                if(map[i][j] == PATH){
                    current_id = id_inMap[i][j];
                    //if there is an enemy --&gt; different from -1
                    //and if the enemy is alive (health of the enemy is greater than 0)
                    if(current_id != -1 &amp;&amp; ((current_id &lt; NUM_SQUARES &amp;&amp; square_health[current_id] &gt; 0) || (current_id &gt;= NUM_SQUARES &amp;&amp; circle_health[current_id - NUM_SQUARES] &gt; 0))){
                        current_time = activation_order[current_id];
                        if(!found || current_time &lt; best_time || (current_time == best_time &amp;&amp; current_id &gt;= 0 &amp;&amp; current_id &lt;= (NUM_SQUARES-1) &amp;&amp; !(best_id &gt;= 0 &amp;&amp; best_id &lt;= (NUM_SQUARES-1)))){
                            found = true;
                            best_id = current_id;
                            best_time = current_time;
                        }
                    }
                    
                } 
            }
                
        }

    // Top and bottom rows (excluding corners)
    for(i = x-r+1; i &lt;= x+r-1; i++){
			if(i &gt;= 0 &amp;&amp; i &lt; WIDTH){
                //top
				if( y-r &gt;=0){
                    j = y-r;
                    //if the coordinate is a path
                    if(map[i][j] == PATH){
                        current_id = id_inMap[i][j];
                       //if there is an enemy --&gt; different from -1
                       //and if the enemy is alive (health of the enemy is greater than 0)
                       if(current_id != -1 &amp;&amp; ((current_id &lt; NUM_SQUARES &amp;&amp; square_health[current_id] &gt; 0) || (current_id &gt;= NUM_SQUARES &amp;&amp; circle_health[current_id - NUM_SQUARES] &gt; 0))){
                            current_time = activation_order[current_id];
                            if(!found || current_time &lt; best_time || (current_time == best_time &amp;&amp; current_id &gt;= 0 &amp;&amp; current_id &lt;= (NUM_SQUARES-1) &amp;&amp; !(best_id &gt;= 0 &amp;&amp; best_id &lt;= (NUM_SQUARES-1)))){
                                found = true;
                                best_id = current_id;
                                best_time = current_time;
                            }
                        }
                    
                    }   
                }
                //bottom
				if(y+r &lt; HEIGHT){
                    j = y+r;
                    //if the coordinate is a path
                    if(map[i][j] == PATH){
                        current_id = id_inMap[i][j];
                        //if there is an enemy --&gt; different from -1
                        //and if the enemy is alive (health of the enemy is greater than 0)
                        if(current_id != -1 &amp;&amp; ((current_id &lt; NUM_SQUARES &amp;&amp; square_health[current_id] &gt; 0) || (current_id &gt;= NUM_SQUARES &amp;&amp; circle_health[current_id - NUM_SQUARES] &gt; 0))){
                            current_time = activation_order[current_id];
                            if(!found || current_time &lt; best_time || (current_time == best_time &amp;&amp; current_id &gt;= 0 &amp;&amp; current_id &lt;= (NUM_SQUARES-1) &amp;&amp; !(best_id &gt;= 0 &amp;&amp; best_id &lt;= (NUM_SQUARES-1)))){
                                found = true;
                                best_id = current_id;
                                best_time = current_time;
                            }
                        }                   
                    }
                }					
			}
		}

        if (found) {
            output_id = best_id;
        } else {
            r++;
        }
    }
    return found;
}*/

int acquire_target(){
    return output_id;
}

int abs_val(int v) {
    return (v &lt; 0) ? -v : v;
}

int chebyshev_distance(int x, int y, int tur_x, int tur_y) {
    int dx = abs_val(x - tur_x);
    int dy = abs_val(y - tur_y);
    return (dx &gt; dy) ? dx : dy;
}


bool find_target(int r, int rof, int x, int y){
    //scroll through square
    //scroll through circle
    bool found, square;
    int i,j;
    int min_distance, current_distance;
    int min_id; 
    int min_time;
    int current_time;
    
    square = false;
    
    for (i = 0; i &lt; NUM_SQUARES; i++){
        if(sqrs_pos[i][0] &gt; -1 &amp;&amp; sqrs_pos[i][1] &gt;-1){
            if (abs_val(sqrs_pos[i][0] - x) &lt;= r &amp;&amp; abs_val(sqrs_pos[i][1] - y) &lt;= r) {
                // within Chebyshev range
                current_distance = chebyshev_distance(sqrs_pos[i][0], sqrs_pos[i][1], x, y);
                if (!found){
                    found = true;
                    square = true;
                    min_distance = current_distance;
                    min_id = i;
                    min_time = activation_order[i];
                } else {
                    if(current_distance &lt; min_distance){
                        min_distance = current_distance;
                        min_id = i;
                        min_time = activation_order[i];
                    } else if(current_distance == min_distance){
                        current_time = activation_order[i];
                        if(current_time &gt; min_time){
                            min_distance = current_distance;
                            min_id = i;
                            min_time = activation_order[i];
                        }
                    }
                }
            }
        }
    }
    
    for (j=0; j &lt; NUM_CIRCLES; j++){
        if(circles_pos[j][0] &gt; -1 &amp;&amp; circles_pos[j][1] &gt; -1){
            if (abs_val(circles_pos[j][0] - x) &lt;= r &amp;&amp; abs_val(circles_pos[j][1] - y) &lt;= r) {
                // within Chebyshev range
                current_distance = chebyshev_distance(circles_pos[j][0], circles_pos[j][1], x, y);
                if (!found){
                    found = true;             
                    min_distance = current_distance;
                    min_id = j;
                    min_time = activation_order[j+NUM_SQUARES];
                } else {
                    if(current_distance &lt; min_distance){
                        square = false;
                        min_distance = current_distance;
                        min_id = j;
                        min_time = activation_order[j+NUM_SQUARES];
                    } else if(current_distance == min_distance){
                        if(!square){
                            current_time = activation_order[j+NUM_SQUARES];
                            if(current_time &gt; min_time){
                                min_distance = current_distance;
                                min_id = j;
                                min_time = activation_order[j+NUM_SQUARES];
                            }
                        }
                    }
                }
            }
        }
    }

    if(found){
        output_id = (square) ? min_id : min_id + NUM_SQUARES;
    }

    return found;
}
</declaration>
		<location id="id43" x="-3646" y="-1190">
			<name x="-3663" y="-1224">idle</name>
		</location>
		<location id="id44" x="-3060" y="-1190">
			<name x="-3102" y="-1224">ready_to_fire</name>
			<urgent/>
		</location>
		<location id="id45" x="-2507" y="-1190">
			<name x="-2533" y="-1224">fire</name>
			<label kind="invariant" x="-2567" y="-1181">turret_clock&gt;=rof</label>
		</location>
		<init ref="id43"/>
		<transition id="id46">
			<source ref="id45"/>
			<target ref="id44"/>
			<label kind="guard" x="-2822" y="-1377">turret_clock&lt;=rof</label>
			<label kind="synchronisation" x="-2822" y="-1343">shoot[target_id]!</label>
			<label kind="assignment" x="-3026" y="-1317">apply_damage(target_id, atk),
present = find_target(range, rof, coord[0], coord[1])</label>
			<nail x="-2507" y="-1351"/>
			<nail x="-3060" y="-1351"/>
		</transition>
		<transition id="id47">
			<source ref="id44"/>
			<target ref="id43"/>
			<label kind="guard" x="-3519" y="-1105">!present</label>
			<nail x="-3060" y="-1088"/>
			<nail x="-3646" y="-1088"/>
		</transition>
		<transition id="id48">
			<source ref="id44"/>
			<target ref="id45"/>
			<label kind="guard" x="-2881" y="-1215">present</label>
			<label kind="assignment" x="-2958" y="-1181">target_id = acquire_target()</label>
		</transition>
		<transition id="id49">
			<source ref="id43"/>
			<target ref="id44"/>
			<label kind="synchronisation" x="-3502" y="-1173">turret_notify?</label>
			<label kind="assignment" x="-3604" y="-1190">present = find_target(range, rof, coord[0], coord[1])</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
C0 = EnemyCircle(0);
C1 = EnemyCircle(1);
C2 = EnemyCircle(2);
S0 = EnemySquare(0);
S1 = EnemySquare(1);
S2 = EnemySquare(2);
M = Map();
T(const id_t id) = Turret(ranges[id], rofs[id], atks[id], locations[id], id);
// List one or more processes to be composed into a system.
system S0, C0, M, T;</system>
	<queries>
		<query>
			<formula>A[] not deadlock</formula>
			<comment/>
			<result outcome="failure" type="quality" timestamp="2025-04-26 16:53:53 +0200">
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; C0.Leave and C1.Leave and C2.Leave and
    S0.Leave and S1.Leave and S2.Leave
</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-04-26 17:09:46 +0200">
			</result>
		</query>
	</queries>
</nta>
